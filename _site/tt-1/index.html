<!DOCTYPE html>
<html>
  <head>
    <title>1 + 1 = 2 – Carl J. Factora – Writer | Mathematician | Programmer | SSBM Fox Main</title>

        <meta charset="utf-8" />
    <meta content='text/html; charset=utf-8' http-equiv='Content-Type'>
    <meta http-equiv='X-UA-Compatible' content='IE=edge'>
    <meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1.0'>

    
    <meta name="description" content="Writer | Mathematician | Programmer | SSBM Fox Main">
    <meta property="og:description" content="Writer | Mathematician | Programmer | SSBM Fox Main" />
    
    <meta name="author" content="Carl J. Factora" />

    
    <meta property="og:title" content="1 + 1 = 2" />
    <meta property="twitter:title" content="1 + 1 = 2" />
    

    <!--[if lt IE 9]>
      <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="alternate" type="application/rss+xml" title="Carl J. Factora - Writer | Mathematician | Programmer | SSBM Fox Main" href="/feed.xml" />

    <!-- Created with Jekyll Now - http://github.com/barryclark/jekyll-now -->
  </head>

  <body>
    <div class="wrapper-masthead">
      <div class="container">
        <header class="masthead clearfix">
          <a href="/" class="site-avatar"><img src="https://ivanthetricourne.github.io/images/me.jpg" /></a>

          <div class="site-info">
            <h1 class="site-name"><a href="/">Carl J. Factora</a></h1>
            <p class="site-description">Writer | Mathematician | Programmer | SSBM Fox Main</p>
          </div>

          <nav>
            <a href="/">Blog</a>
	    <a href="/projects">Projects</a>
	    <a href="/functional-programming">F.P.</a>
            <a href="/about">About</a>
          </nav>
        </header>
      </div>
    </div>

    <div id="main" role="main" class="container">
      <article class="page">

  <h1>1 + 1 = 2</h1>

  <div class="entry">
    <p><em>Reach for the stars</em> (i.e., the universal supertype).</p>

<p>In Type Theory, there is what is known as the <em>universal supertype</em>, or <em>top</em>. This type is rather simple but plays a key role in keeping our concept of mathematics in tact. In a fully dependently typed language (i.e., Agda), we can define this type as follows:</p>

<div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="kr">data</span> <span class="err">⊤</span> <span class="o">:</span> <span class="kt">Set</span> <span class="kr">where</span>
  <span class="o">*</span> <span class="o">:</span> <span class="err">⊤</span>
</code></pre>
</div>

<p>That is, the type ⊤ has exactly (and only) one element: <code class="highlighter-rouge">*</code>. What can we do this type? To answer this question, let’s familiarize ourselves with a new concept called <em>induction principles</em>.</p>

<p>Induction principles aren’t too different from the more familiar <em>recursion principles</em> that are used in a lot of different programming languages (another name for those is <em>eliminator</em> or a <em>fold</em> function). Unlike recursion principles, induction principles are more flexible and are not only capable of returning other values. To make this point clear, let’s write the recursion principle for the ⊤ type:</p>
<div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="n">rec</span><span class="err">⊤</span> <span class="o">:</span> <span class="p">(</span><span class="kt">C</span> <span class="o">:</span> <span class="kt">Set</span><span class="p">)</span> <span class="err">→</span> <span class="kt">C</span> <span class="err">→</span> <span class="err">⊤</span> <span class="err">→</span> <span class="kt">C</span>
<span class="n">rec</span><span class="err">⊤</span> <span class="kt">C</span> <span class="n">c</span> <span class="o">*</span> <span class="o">=</span> <span class="n">c</span>
</code></pre>
</div>
<p>Now, you might be saying that this function looks rather silly. You’re right. It’s basically an identity function with extra, unused parameters. This function, nonetheless, is the proper way of defining the recursion principle for the ⊤ type. Why? Well, the role of a recursion principle is essentially to map every element of a giving type to another. Since there’s only one element in ⊤, we simply take a single element from any other type (in this case the type <code class="highlighter-rouge">C</code>, as specified by <code class="highlighter-rouge">rec⊤</code>) and return it (viz. <code class="highlighter-rouge">c</code>).</p>

<p>The induction principle does the same thing, except the certain “element” we are returning is not exactly a <em>value</em> (e.g. <code class="highlighter-rouge">"Banana"</code>, <code class="highlighter-rouge">True</code>, <code class="highlighter-rouge">42</code>) but is a <em>proof</em> concerning elements of the respective type.</p>
<div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="n">ind</span><span class="err">⊤</span> <span class="o">:</span> <span class="p">(</span><span class="kt">C</span> <span class="o">:</span> <span class="err">⊤</span> <span class="err">→</span> <span class="kt">Set</span><span class="p">)</span> <span class="err">→</span> <span class="kt">C</span> <span class="o">*</span> <span class="err">→</span> <span class="p">(</span><span class="n">x</span> <span class="o">:</span> <span class="err">⊤</span><span class="p">)</span> <span class="err">→</span> <span class="kt">C</span> <span class="n">x</span>
<span class="n">ind</span><span class="err">⊤</span> <span class="kt">C</span> <span class="n">c</span> <span class="o">*</span> <span class="o">=</span> <span class="n">c</span>
</code></pre>
</div>
<p>And that, ladies and gentlemen, is a <em>dependent type</em>! To show how to use this function, let’s prove the following:</p>
<div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="n">x</span> <span class="o">:</span> <span class="err">⊤</span><span class="p">)</span> <span class="err">→</span> <span class="n">x</span> <span class="err">≡</span> <span class="o">*</span>
</code></pre>
</div>
<p>That is, for every element that is in ⊤, that element is <code class="highlighter-rouge">*</code>. The element that inhabits the above type (i.e., the <em>value</em> that is of that type) can be constructed using an induction principle. Also, this form of proof, where we take a type and prove something about the identity of its elements, is called a <em>uniqueness of identity proof</em>. Our proof looks like this:</p>
<div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="n">uip</span><span class="err">⊤</span> <span class="o">:</span> <span class="p">(</span><span class="n">x</span> <span class="o">:</span> <span class="err">⊤</span><span class="p">)</span> <span class="err">→</span> <span class="n">x</span> <span class="err">≡</span> <span class="o">*</span>
<span class="n">uip</span><span class="err">⊤</span> <span class="o">=</span> <span class="n">ind</span><span class="err">⊤</span> <span class="p">(</span><span class="err">λ</span> <span class="n">top</span> <span class="err">→</span> <span class="n">top</span> <span class="err">≡</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">refl</span> <span class="o">*</span><span class="p">)</span>
</code></pre>
</div>
<p>Let’s take the time to digest what this code is saying:</p>

<ol>
  <li>This function is named <code class="highlighter-rouge">uip⊤</code></li>
  <li>This function is a proof that every element in ⊤ is <code class="highlighter-rouge">*</code>.</li>
  <li>To do (2), we use <code class="highlighter-rouge">ind⊤</code>, since we want to make a statement about <em>all</em> elements in ⊤ (this concept applies for more complex types).</li>
  <li>The first argument of <code class="highlighter-rouge">ind⊤</code> is called the <em>motive</em> and reflects the type of the proof we are trying to construct.</li>
  <li><code class="highlighter-rouge">(refl *)</code> is of type <code class="highlighter-rouge">* ≡ *</code></li>
</ol>


  </div>
</article>

    </div>

    <div class="wrapper-footer">
      <div class="container">
        <footer class="footer">
          



<a href="https://github.com/IvantheTricourne"><i class="svg-icon github"></i></a>

<a href="https://www.linkedin.com/in/cfactora"><i class="svg-icon linkedin"></i></a>


<a href="https://www.twitter.com/CJF_setBaNG"><i class="svg-icon twitter"></i></a>



        </footer>
      </div>
    </div>

    

  </body>
</html>
